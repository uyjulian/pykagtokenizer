
//---------------------------------------------------------------------------
// KAG Parser Utility Class
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
/*
  KAG System (Kirikiri Adventure Game System) is an application script for
  TVP(Kirikiri), providing core system for Adventure Game/Visual Novel.
  KAG has a simple tag-based mark-up language ("scenario file").
  Version under 2.x of KAG is slow since the parser is written in TJS1.
  KAG 3.x uses TVP's internal KAG parser written in C++ in this unit, will
  acquire speed in compensation for ability of customizing.
*/
//---------------------------------------------------------------------------

global.TVPKAGNoLine = "Attempt to load scenario file %1 is empty";
global.TVPKAGCannotOmmitFirstLabelName = "The first label name of the scenario file cannot be omitted";
global.TVPInternalError = "Internal Error: at %1 line %2";
global.TVPKAGMalformedSaveData = "Bookmark data is abnormal. Data may be corrupted";
global.TVPKAGLabelNotFound = "Label %s not found in scenario file %s";
global.TVPKAGInlineScriptNotEnd = "[endscript] or @endscript not found";
global.TVPKAGSyntaxError = "Tag syntax error. Check for \'[\' and \']\' balance, \" and \" balance, missing spaces, extra line breaks, missing required attributes, etc.";
global.TVPKAGSpecifyKAGParser = "Please specify an object of KAGParser class";

//---------------------------------------------------------------------------
// tTVPScenarioCacheItem : Scenario Cache Item
//---------------------------------------------------------------------------
class __internal_KAGParser_ScenarioCacheItem
{
	function __internal_KAGParser_ScenarioCacheItem(name, isstring)
	{
		this.lines = null;
		this.lineCount = 0;
		this.labelCache = %[]; // Label cache
		this.labelAliases = %[];
		this.labelCached = false; // whether the label is cached
		this.loadScenario(name, isstring);
	}

	// load file or string to buffer
	function loadScenario(name, isstring)
	{
		// load scenario from file or string to buffer
		if ((typeof(name) === "Object") && (name instanceof "Array"))
		{
			this.lines = name;
		}
		else if ((typeof(name) === "String") && isstring)
		{
			// when onScenarioLoad returns string;
			// assumes the string is scenario
			this.lines = name.split("\n");
		}
		else if (typeof(name) === "String")
		{
			// else load from file
			this.lines = [];
			this.lines.load(name);
		}
		else
		{
			throw new Exception("Name not Array or String!");
		}
		// pass1: count lines
		// pass2: split lines
		var leading_tabs_regexp = /^\t+/g;
		for (var i = 0; i < this.lines.count; i += 1)
		{
			this.lines[i] = this.lines[i].replace(leading_tabs_regexp, "");  // skip leading tabs
		}

		// tab-only last line will not be counted in pass2, thus makes
		// pass2 counted lines are lesser than pass1 lines.

		this.ensureLabelCache();
	}

	function ensureLabelCache()
	{
		// construct label cache
		if (!this.labelCached)
		{
			// make label cache
			var page_name_regexp = /\|.*$/g;
			var prevlabel = "";
			for (var i = 0; i < this.lines.count; i += 1)
			{
				var line = this.lines[i];
				if (line.length >= 2 && line[0] === "*")
				{
					// page name found
					var label = line.replace(page_name_regexp, "");
					if (label.length === 1)
					{
						if (prevlabel.length === 0)
						{
							throw new Exception(this.TVPKAGCannotOmmitFirstLabelName);
						}
						label = prevlabel;
					}

					prevlabel = label;

					if (this.labelCache[label] !== void)
					{
						// previous label name found (duplicated label)
						this.labelCache[label][1] += 1;
						label = ("%s:%s").sprintf(label, i);
					}

					this.labelCache[label] = [i, 1];
					this.labelAliases[i] = label;
				}
			}
			this.labelCached = true;
		}
	}

	function getLabelAliasFromLine(line)
	{
		return this.labelAliases[line];
	}

	function getLines()
	{
		return this.lines;
	}

	function getLineCount()
	{
		return this.lines.count;
	}

	function getLabelCache()
	{
		return this.labelCache;
	}

}

//---------------------------------------------------------------------------
// tTVPScenarioCache
//---------------------------------------------------------------------------
global.__internal_KAGParser_scenarios = %[];

global.__internal_KAGParser_getScenario = function(storagename, isstring)
{
	// compact interface initialization
	if (isstring)
	{
		// we do not cache when the string is passed as a scenario
		return new __internal_KAGParser_ScenarioCacheItem(storagename, isstring);
	}

	if (global.__internal_KAGParser_scenarios[storagename] === void)
	{
		global.__internal_KAGParser_scenarios[storagename] = new __internal_KAGParser_ScenarioCacheItem(storagename, isstring);
	}
	return global.__internal_KAGParser_scenarios[storagename];
};

//---------------------------------------------------------------------------
// tTJSNI_KAGParser : KAGParser TJS native instance
//---------------------------------------------------------------------------
// KAGParser is implemented as a TJS native class/object
class __internal_KAGParser
{
	function __internal_KAGParser()
	{
		this.scenario = null; // this is scenario object
		this.lines = null; // is copied from Scenario
		this.lineCount = 0; // is copied from Scenario
		this.storageName = "";
		this.buffer = ""; // not stored
		this.curLine = 0; // current processing line
		this.curPos = 0; // current processing position ( column )
		this.curLineStr = null; // current line string; not stored
		this.curLabel = ""; // Current Label
		this.curPage = ""; // Current Page Name; not stored
		this.tagLine = 0; // line number of previous tag; not stored

		// retrieve DictClear method and DictObj object
		// retrieve clear method from dictclass
		this.dicClear = global.Dictionary.clear; // Dictionary.Clear method pointer
		this.dicObj = %[]; // DictionaryObject
	}

	function construct(tjs_obj)
	{
	}

	function finalize()
	{
		// invalidate this object

		// release objects
		this.dicClear = void;
		this.dicObj = void;

		this.clearBuffer();
	}

	function loadScenario(name, buffer=null)
	{
		// load scenario to buffer
		if (name === this.storageName)
		{
			// avoid re-loading
			this.rewind();
		}
		else
		{
			this.clearBuffer();

			// fire onScenarioLoad
			var ret = buffer;
			if (typeof(ret) === "String")
			{
				this.scenario = global.__internal_KAGParser_getScenario(ret, true);
			}
			else
			{
				this.scenario = global.__internal_KAGParser_getScenario(name, false);
			}
			this.lines = this.scenario.getLines();
			this.lineCount = this.scenario.getLineCount();
			
			this.rewind();

			this.storageName = name;
		}

	}

	function getStorageName()
	{
		return this.storageName;
	}

	// clear all states
	function clear()
	{
		// clear all states
		// TVPClearScnearioCache(); // also invalidates the scenario cache
		this.clearBuffer();
	}

	// clear internal buffer
	function clearBuffer()
	{
		// clear internal buffer
		if (typeof(this.scenario) === "Object")
		{
			this.scenario = null;
			this.lines = null;
			this.curLineStr = null;
		}
		this.storageName = "";
	}

	// set current position to first
	function rewind()
	{
		// set current position to first
		this.curLine = 0;
		this.curPos = 0;
		this.curLineStr = this.lines[0];
	}

	function TVPIsWS(ch)
	{
		// is white space ?
		return (ch === " " || ch === "\t");
	}

	// skip comment or label and go to next line
	function skipCommentOrLabel()
	{
		// skip comment or label, and go to next line.
		// fire OnScript event if [script] thru [endscript] ( or @script thru
		// @endscript ) is found.
		this.scenario.ensureLabelCache();
		this.curPos = 0;
		if (this.curLine >= this.lineCount)
		{
			return null;
		}

		for (; this.curLine < this.lineCount; this.curLine += 1)
		{
			if (this.lines === null)
			{
				return null; // in this loop, Lines can be NULL when onScript does so.
			}

			var p = this.lines[this.curLine];
			if (p[0] === ";")
			{
				{
					var val = %[];
					val["type"] = "comment";
					val["value"] = p.substring(1, p.length - 1);
					this.curLine += 1;
					return %[tagname: val];
				}
				continue; // comment
			}

			if (p[0] === "*")
			{
				// label
				var vl = p.indexOf("|");
				var pagename;
				if (vl === -1)
				{
					this.curLabel = this.scenario.getLabelAliasFromLine(this.curLine);
					this.curPage = "";
					pagename = false;
				}
				else
				{
					this.curLabel = this.scenario.getLabelAliasFromLine(this.curLine);
					this.curPage = p.substring(vl + 1);
					pagename = true;
				}
				// fire onLabel callback event
				{
					var val = %[];
					val["type"] = "label";
					if (pagename)
					{
						val["pagename"] = this.curPage;
					}
					val["value"] = this.curLabel.substring(1, p.length - 1);
					this.curLine += 1;
					return %[tagname: val];
				}
				continue;
			}

			if ((p === "[iscript]" || p === "[iscript]\\") || (p === "@iscript"))
			{
				// inline TJS script

				var script = "";
				this.curLine += 1;
				var script_start = this.curLine;

				for (; this.curLine < this.lineCount; this.curLine += 1)
				{
					var p = this.lines[this.curLine];
					if (((p === "[endscript]" || p === "[endscript]\\")) || (p === "@endscript"))
					{
						break;
					}
					if (true)
					{
						script += p;
						script += "\r\n";
					}
				}

				if (this.curLine === this.lineCount)
				{
					throw new Exception(global.TVPKAGInlineScriptNotEnd);
				}

				// fire onScript callback event
				{
					var val = %[];
					val["type"] = "iscript";
					val["value"] = script;
					this.curLine += 1;
					return %[tagname: val];
				}
				continue;
			}

			break;
		}

		if (this.curLine >= this.lineCount)
		{
			return null;
		}

		this.curLineStr = this.lines[this.curLine];

		return;
	}

	function kagStepNext(ldelim)
	{
		if (ldelim === "")
		{
			this.curLine += 1;
			this.curPos = 0;
		}
		else
		{
			this.curPos += 1;
		}
	}

	function _getNextTag()
	{
		// get next tag and return information dictionary object.
		// return NULL if the tag not found.
		// normal characters are interpreted as a "ch" tag.
		// CR code is interpreted as a "r" tag.
		// returned tag's line number is stored to TagLine.
		// tag paremeters are stored into return value.
		// tag name is also stored into return value, naemd "__tag".

		// pretty a nasty code.

		if (this.curLine >= this.lineCount)
		{
			return null;
		}
		if (this.lines === null)
		{
			return null;
		}

		while (true)
		{
			(this.dicClear incontextof this.dicObj)(); // clear dictionary object

			if (this.curLine >= this.lineCount)
			{
				break; // all of scenario was decoded 
			}

			var tagstartpos = this.curPos;

			if (this.curPos === 0)
			{
				var commentorlabel = this.skipCommentOrLabel();
				if (typeof(commentorlabel) === "Object")
				{
					return commentorlabel;
				}
			}

			var ldelim; // last delimiter

			if (this.curPos === 0 && this.curLineStr[0] === "@")
			{
				// line command mode
				ldelim = ""; // tag last delimiter is a null terminater
			}
			else
			{
				if (
					(this.curLineStr.length === this.curPos) ||
					(this.curLineStr[this.curPos] !== "[") ||
					(
						this.curLineStr.length !== this.curPos &&
						this.curLineStr.length !== this.curPos + 1 &&
						this.curLineStr[this.curPos] === "[" &&
						this.curLineStr[this.curPos + 1] === "["
					)
				)
				{
					// normal character
					if (this.curLineStr.length === this.curPos)
					{
						// line ended
						this.curLine += 1;
						this.curPos = 0;
						continue;
					}
					this.tagLine = this.curLine;
					var ch = this.curLineStr[this.curPos];

					if (ch === "\t")
					{
						this.curPos += 1;
						continue;
					}
					else if (ch !== "\n")
					{
						this.dicObj["tagname"] = "ch";
						this.dicObj["text"] = ch;
					}
					else
					{
						// \n  ( reline )
						this.dicObj["tagname"] = "r";
					}

					if (this.curLineStr[this.curPos] === "[")
					{
						this.curPos += 1;
					}
					this.curPos += 1;

					if (true)
					{
						return this.dicObj;
					}
					continue;
				}

				ldelim = "]";
			}

			// a tag
			this.tagLine = this.curLine;
			var tagstart = this.curPos;
			this.curPos += 1;

			if (this.curLineStr.length === this.curPos)
			{
				throw new Exception(global.TVPKAGSyntaxError);
			}

			// tag name
			while (this.curLineStr.length !== this.curPos && this.TVPIsWS(this.curLineStr[this.curPos]))
			{
				this.curPos += 1;
			}
			if (this.curLineStr.length === this.curPos)
			{
				throw new Exception(global.TVPKAGSyntaxError);
			}
			// XXX: verify offset
			var tagnamestart = this.curPos;
			while (this.curLineStr.length !== this.curPos && !this.TVPIsWS(this.curLineStr[this.curPos]) && this.curLineStr[this.curPos] !== ldelim)
			{
				this.curPos += 1;
			}

			if (tagnamestart === this.curPos)
			{
				throw new Exception(global.TVPKAGSyntaxError);
			}

			var tagname = this.curLineStr.substring(tagnamestart, this.curPos - tagnamestart);
			tagname = tagname.toLowerCase();
			{
				this.dicObj["tagname"] = tagname;
			}

			// tag attributes
			while (true)
			{
				while (this.curLineStr.length !== this.curPos && this.TVPIsWS(this.curLineStr[this.curPos]))
				{
					this.curPos += 1;
				}
				if ((ldelim === "" && this.curLineStr.length === this.curPos) || this.curLineStr[this.curPos] === ldelim)
				{
					// tag-specific processing
					{
						// not a control tag

						this.kagStepNext(ldelim);

						return this.dicObj;

						break;
					}

					this.kagStepNext(ldelim);
					break;
				}

				if (this.curLineStr.length === this.curPos)
				{
					throw new Exception(global.TVPKAGSyntaxError);
				}

				var attribnamestart = this.curPos;
				while (this.curLineStr.length !== this.curPos && !this.TVPIsWS(this.curLineStr[this.curPos]) && this.curLineStr[this.curPos] !== "=" && (ldelim !== "" ? this.curLineStr[this.curPos] !== ldelim : true))
				{
					this.curPos += 1;
				}

				var attribnameend = this.curPos;

				var attribname = this.curLineStr.substring(attribnamestart, attribnameend - attribnamestart);

				// =
				while (this.curLineStr.length !== this.curPos && this.TVPIsWS(this.curLineStr[this.curPos]))
				{
					this.curPos += 1;
				}

				var entity = false;
				var value = "";

				if (this.curLineStr[this.curPos] !== "=")
				{
					// arrtibute value omitted
					value = "true"; // always true
				}
				else
				{
					if (this.curLineStr.length === this.curPos)
					{
						throw new Exception(global.TVPKAGSyntaxError);
					}
					this.curPos += 1;
					if (this.curLineStr.length === this.curPos)
					{
						throw new Exception(global.TVPKAGSyntaxError);
					}
					while (this.curLineStr.length !== this.curPos && this.TVPIsWS(this.curLineStr[this.curPos]))
					{
						this.curPos += 1;
					}
					if (this.curLineStr.length === this.curPos)
					{
						throw new Exception(global.TVPKAGSyntaxError);
					}

					// attrib value
					var vdelim = 0; // value delimiter

					if (this.curLineStr[this.curPos] === "&")
					{
						entity = true;
						this.curPos += 1;
					}

					if (this.curLineStr[this.curPos] === "\"" || this.curLineStr[this.curPos] === "'")
					{
						vdelim = this.curLineStr[this.curPos];
						this.curPos += 1;
					}

					var valuestart = this.curPos;

					while (this.curLineStr.length !== this.curPos && (vdelim !== 0 ? (this.curLineStr[this.curPos] !== vdelim) : (this.curLineStr[this.curPos] !== ldelim && !this.TVPIsWS(this.curLineStr[this.curPos]))))
					{
						if (this.curLineStr[this.curPos] === "`")
						{
							// escaped with '`'
							this.curPos += 1;
							if (this.curLineStr.length === this.curPos)
							{
								throw new Exception(global.TVPKAGSyntaxError);
							}
						}
						this.curPos += 1;
					}

					if (ldelim !== "" && this.curLineStr.length === this.curPos)
					{
						throw new Exception(global.TVPKAGSyntaxError);
					}

					var valueend = this.curPos;

					if (vdelim !== 0)
					{
						this.curPos += 1;
					}

					// unescape ` character of value
					value = this.curLineStr.substring(valuestart, valueend - valuestart);

					if (valuestart !== valueend)
					{
						// value has at least one character
						var value_pos = 0;
						if (value[value_pos] === "&")
						{
							entity = true;
							value_pos += 1;
						}
						var newvalue = "";
						while (value.length !== value_pos)
						{
							if (value[value_pos] === "`")
							{
								value_pos += 1;
								if (value.length === value_pos)
								{
									break;
								}
							}
							newvalue += value[value_pos];
							value_pos += 1;
						}

						value = newvalue;
					}
				}

				// special attibute processing
				var valueVariant;
				{
					// process expression entity argument
					if (entity)
					{
						valueVariant = %[];
						valueVariant["type"] = "entity";
						valueVariant["value"] = value;
					}
					else
					{
						valueVariant = value;
					}
				}

				// store value into the dictionary object
				if (attribname !== "")
				{
					this.dicObj[attribname] = valueVariant;
				}
			}
		}

		return null;
	}

	function getParsedScenario()
	{
		var res = void;
		var last_line = this.curLine;
		var last_line_str = this.curLineStr;
		var cur_line_array = [];
		var all_lines_array = [];
		var char_array = [];
		while (res !== null)
		{
			res = this._getNextTag();
			if (res !== null && res !== void)
			{
				if (this.curLine !== last_line || this.curLineStr !== last_line_str)
				{
					if (char_array.count > 0)
					{
						cur_line_array.add(char_array.join(""));
						char_array.clear();
					}
					last_line = this.curLine;
					last_line_str = this.curLineStr;
					all_lines_array.add(cur_line_array);
					cur_line_array = [];
				}
				var rres = %[];
				var rres2 = [];
				(Dictionary.assignStruct incontextof rres)(res);
				rres2.assign(rres);
				if (rres["tagname"] === "ch" && typeof(rres["text"]) === "String" && rres["text"].length === 1 && rres2.count === 4)
				{
					char_array.add(rres["text"]);
				}
				else if (char_array.count > 0)
				{
					cur_line_array.add(char_array.join(""));
					char_array.clear();
					cur_line_array.add(rres);
				}
				else
				{
					cur_line_array.add(rres);
				}
				
				
			}
		}
		if (char_array.count > 0)
		{
			cur_line_array.add(char_array.join(""));
			char_array.clear();
		}
		if (cur_line_array.count > 0)
		{
			all_lines_array.add(cur_line_array);
		}
		return all_lines_array;
	}

	function getCurLabel()
	{
		return this.curLabel;
	}

	function getCurLine()
	{
		return this.curLine;
	}

	function getCurPos()
	{
		return this.curPos;
	}

	function getCurLineStr()
	{
		return this.curLineStr;
	}

}

class KAGParser
{
	var __internal_KAGParser_instance;
	/**
	 * @summary Building a KAGParser object
	 *
	 * Build an object of class KAGParser.
	 * @constructor
	 */	
	function KAGParser()
	{
		this.__internal_KAGParser_instance = new __internal_KAGParser();
		this.__internal_KAGParser_instance.construct(this);
	}

	function finalize()
	{
	}

	/**
	 * @summary Loading a scenario
	 *
	 * Loads the specified scenario storage and sets the scenario loading position to the beginning of the storage.
	 * @param {String} name - Specifies the scenario storage to load.
	 */	
	function loadScenario(name, buffer)
	{
		return this.__internal_KAGParser_instance.loadScenario(name, buffer);
	}

	/**
	 * @summary Get parsed scenario
	 * @return {Array} Tag information.
	 */	
	function getParsedScenario()
	{
		var res = this.__internal_KAGParser_instance.getParsedScenario();
		if (res === null)
		{
			return void;
		}
		return res;
	}

	/**
	 * @summary Clear object
	 *
	 * Clears the state of the object.
	 */	
	function clear()
	{
		return this.__internal_KAGParser_instance.clear();
	}

	/**
	 * @summary Number of lines in the current line
	 *
	 * Indicates what line the current line is in storage.
	 * @access r
	 */
	property curLine
	{
		getter
		{
			return this.__internal_KAGParser_instance.curLine;
		}
	}

	/**
	 * @summary The position of the character on the current line
	 *
	 * Indicates the current character number in the current line.
	 * @access r
	 */
	property curPos
	{
		getter
		{
			return this.__internal_KAGParser_instance.curPos;
		}
	}

	/**
	 * @summary Current line string
	 *
	 * Represents the string on the current line.
	 * @access r
	 */
	property curLineStr
	{
		getter
		{
			return this.__internal_KAGParser_instance.curLineStr;
		}
	}

	/**
	 * @summary Current storage
	 *
	 * Represents the current storage.
	 * You can also set the value. In that case, the specified storage is read.
	 * @access r/w
	 */
	property curStorage
	{
		getter
		{
			return this.__internal_KAGParser_instance.storageName + "";
		}
		setter(v)
		{
			this.__internal_KAGParser_instance.loadScenario(v);
		}
	}

	/**
	 * @summary Current label
	 *
	 * Represents the current label.
	 * @access r
	 */
	property curLabel
	{
		getter
		{
			return this.__internal_KAGParser_instance.curLabel + "";
		}
	}
}
